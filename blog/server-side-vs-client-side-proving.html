<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server-Side Proving vs Client-Side Proving</title>
    <link rel="icon" type="image/png" sizes="32x32" href="../images/bonsol-Square-Favicon.png">
    <style>
        /* Monospace styling */
        body {
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.6;
            margin: 0;
            background: #fff;
            color: #333;
            padding: 2rem;
            margin: 0 auto;
        }

        /* Content styling */
        .content {
            background: #fff;
            padding: 0;
            border: none;
            max-width: 1000px;
            margin: 0 auto;
        }

        /* Simplified Navigation styling */
        .nav {
            background: #fff;
            padding: 1rem 0;
            border: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .nav-logo {
            max-width: 200px;
            height: auto;
            margin-right: 2rem;
        }

        .nav-links {
            display: flex;
            align-items: center;
        }

        .nav a {
            color: #333;
            text-decoration: none;
            margin-right: 2rem;
            font-family: 'Courier New', Courier, monospace;
        }

        .nav a:hover {
            text-decoration: underline;
        }

        .nav a.active {
            text-decoration: underline;
        }

        hr {
            border: none;
            height: 1px;
            margin: 2rem 0;
            background: repeating-linear-gradient(90deg,
                #333,
                #333 10px,
                transparent 10px,
                transparent 20px
            );
        }

        .solid-hr {
            border: none;
            height: 1px;
            background-color: #333;
            margin: 0rem 0;
        }

        /* Blog post specific styles */
        .blog-post {
            max-width: 800px;
            margin: 0 auto;
        }

        .blog-post img {
            max-width: 100%;
            height: auto;
            margin: 2rem 0;
        }

        .blog-post ul {
            padding-left: 1.25rem;
        }

        .blog-post ol {
            padding-left: 1.25rem;
        }
    </style>
</head>
<body>
    <div class="content">
        <nav class="nav">
            <a href="../index.html">
                <img src="../images/bonsol-blackword-logo.png" alt="Bonsol" class="nav-logo">
            </a>
            <div class="nav-links">
                <a href="../about.html">About</a>
                <a href="../collective.html">Collective</a>
                <a href="../blog.html" class="active">Blog</a>
                <a href="https://examples.bonsol.org" target="_blank">Examples</a>
                <a href="https://bonsol.gitbook.io/docs" target="_blank">Docs</a>
                <a href="https://x.com/bonsol_labs" target="_blank">X</a>
                <a href="https://discord.gg/kQedumSEdy" target="_blank" style="display: inline-flex; align-items: center;">
                    <svg width="20" height="20" viewBox="0 0 71 55" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z" fill="currentColor"/>
                    </svg>
                </a>
            </div>
        </nav>
        <hr class="solid-hr">

        <div class="blog-post">
            <h1>Server-Side Proving vs Client-Side Proving</h1>

            <figure>
                <img src="../images/client-side.png" alt="Bonsol-Image-Client-Side">
                <!-- <figcaption>Bonsol In Action</figcaption> -->
            </figure>

            <h2>TL;DR</h2>
            <p>The location of proof generation is a core architectural decision that directly affects performance, privacy, trust assumptions, and user experience.</p>
            <p>Server-side proving excels at scale and speed through batching and powerful infrastructure, but increases centralization and exposes sensitive inputs to trusted servers.</p>
            <p>Client-side proving keeps data under user control and aligns with self-sovereign systems though could be prone to constraints.</p>

            <h2>Introduction</h2>
            <p>Zero-knowledge proofs and verifiable computation have moved from academic theory into production systems. They now secure rollups, power privacy-preserving identity systems, enforce compliance rules, and verify off-chain computation across blockchains and enterprises.</p>
            <p>As these systems mature, architectural decisions that once seemed secondary now shape performance, privacy, trust, and long-term scalability. One of the most significant consequences of these decisions is simple:</p>
            <p><strong>Where should proof generation happen: on the server or on the client?</strong></p>
            <p>At first glance, this may look like a deployment detail. In practice, it defines who controls computation, who sees sensitive data, how fast proofs can be produced, and how much trust users must place in infrastructure they do not own.</p>
            <p>This article explores server-side and client-side proving in depth. You will learn how each model works, what trade-offs it introduces, and how modern systems increasingly combine both approaches. By the end, you should have a clear framework for choosing the right proving architecture for your application.</p>

            <h2>Background: Understanding Proving in Verifiable Systems</h2>
            <p>Before comparing architectures, it helps to ground the discussion in first principles. In zero-knowledge and verifiable computation systems, proving refers to the process of generating a cryptographic proof that a computation was executed correctly. The proof convinces a verifier that a statement is true without requiring the verifier to rerun the computation or, in zero-knowledge systems, without revealing private inputs.</p>
            <p>Every such system has three core components:</p>
            <ul>
                <li><strong>The prover</strong>, which performs the computation and generates the proof.</li>
                <li><strong>The verifier</strong>, which efficiently checks the proof.</li>
                <li><strong>The circuit or program</strong> that defines the computation being proven.</li>
            </ul>
            <p>The location of the prover matters because proof generation is computationally expensive. Generating a proof can require orders of magnitude more resources than verifying one. As a result, deciding where the prover runs is not just an optimisation choice. It is a foundational architectural decision.</p>
            <p>Today, proving is used across a wide range of environments, including blockchain rollups, decentralized identity systems, compliance and audit tooling, oracle networks, and off-chain computation frameworks. Each of these contexts places different demands on privacy, throughput, cost, and user experience.</p>

            <h2>What Is Server-Side Proving?</h2>
            <p>Server-side proving means that proofs are generated on a centralized or semi-centralized infrastructure controlled by an operator. Users or applications send inputs to a server, which executes the computation, generates the proof, and returns the result.</p>
            <p>In a typical workflow, a client submits data to an API. The server then runs the proving system, often on specialized hardware, and publishes or returns the resulting proof to be verified elsewhere, such as on-chain or by another service.</p>
            <p>The server then runs the proving system, often on specialized hardware, and publishes or returns the resulting proof to be verified elsewhere, such as on-chain or by another service. This is where Bonsol foundational network operates today, providing dedicated, high-performance infrastructure that handles proof generation reliably at scale.</p>
            <p>Most server-side proving systems run on cloud infrastructure. This may include CPU clusters, GPUs, or purpose-built proving farms optimized for parallel workloads.</p>

            <h3>Advantages of Server-Side Proving</h3>
            <p>The primary advantage of server-side proving is performance. Servers can be provisioned with high-end hardware that far exceeds what most users carry in their pockets. This enables faster proving times, higher throughput, and support for more complex circuits.</p>
            <p>Server-side proving also allows batching and parallelization. Multiple proofs can be generated simultaneously, reducing costs across users and improving overall efficiency. This is particularly important for rollups, bridges, and high-frequency DeFi systems where latency and throughput directly affect usability.</p>
            <p>Operationally, server-side systems are easier to maintain. Upgrades to circuits, proving keys, or hardware can be rolled out centrally without requiring user intervention. For fast-moving systems, this flexibility is often essential.</p>

            <h3>Limitations and Risks of Server-Side Proving</h3>
            <p>The performance benefits of server-side proving come with trade-offs.</p>
            <p>Most importantly, server-side proving increases trust assumptions. Users must trust that the server executes the computation correctly and does not misuse or leak sensitive inputs. While the proof guarantees the correctness of the computation, it does not guarantee the correct handling of private data before proving.</p>
            <p>Privacy in proving is not a binary choice; it is a spectrum. At one end, fully client-side proving keeps inputs entirely on the user’s device, maximizing privacy but often at the cost of performance, latency, and user experience. At the other end, fully server-side proving delivers speed and scale, but introduces trust assumptions around who operates the infrastructure and how sensitive data is handled. Most production systems live between these extremes.</p>
            <p>Bonsol operates deliberately in this middle ground. Built on RISC Zero’s prover network, Bonsol leverages zero-knowledge proofs alongside segmented proving and recursive aggregation, where complex computations are split into smaller shards, proven independently, and combined into a single final proof. This design ensures correctness without revealing private inputs, while also limiting how much information any single prover node ever sees. Combined with diligent management of vetted and trusted prover node operators, Bonsol reduces the trust surface area and data exposure inherent in server-side proving. The result is a pragmatic model of semi-privacy: strong enough for real-world verifiable finance applications, yet performant and scalable enough to run in production today.</p>

            <h2>What Is Client-Side Proving?</h2>
            <p>Client-side proving shifts proof generation to the end user’s environment. The prover runs locally, on a browser, mobile device, wallet, or desktop application. Inputs never leave the user’s device, and only the proof is shared.</p>
            <p>In this model, the user controls both the data and the proving process. The server, if one exists at all, acts only as a verifier or relay.</p>
            <p>Client-side proving workflows typically involve downloading proving keys and circuits ahead of time, executing the computation locally, and submitting the resulting proof for verification.</p>

            <h3>Advantages of Client-Side Proving</h3>
            <p>The defining strength of client-side proving is privacy. Because sensitive inputs never leave the user’s device, there is no need to trust external infrastructure with private data. This aligns naturally with self-custody models, decentralized identity systems, and user-sovereign applications.</p>
            <p>Client-side proving also reduces reliance on centralized operators. The system becomes more resilient to censorship and infrastructure failures, since each user can generate proofs independently.</p>
            <p>From a philosophical standpoint, client-side proving embodies the original promise of zero-knowledge systems: verifiability without trust.</p>

            <h3>Limitations and Challenges of Client-Side Proving</h3>
            <p>The challenges of client-side proving are practical rather than conceptual.</p>
            <p>Proof generation is expensive. On consumer hardware, especially mobile devices, proving can be slow and resource-intensive. Long-proving times degrade user experience and can drain batteries or overheat devices.</p>
            <p>Hardware diversity adds another layer of complexity. A circuit that runs comfortably on a high-end laptop may be unusable on a low-end phone. This limits the size and complexity of computations that can realistically be proven client-side.</p>
            <p>As a result, client-side proving is often constrained to simpler circuits or infrequent operations.</p>

            <h2>Key Differences Between Server-Side and Client-Side Proving</h2>
            <figure>
                <img src="../images/server-side.png" alt="Bonsol Difference">
                <!-- <figcaption>Bonsol In Action</figcaption> -->
            </figure>

            <h2>Hybrid and Delegated Proving Models</h2>
            <p>In practice, many modern systems reject a strict binary choice and adopt hybrid proving architectures.</p>
            <p>Hybrid models split responsibilities between client and server. For example, a client may preprocess or encrypt inputs, while a server performs heavy computation without learning sensitive data. Other systems use delegated proving, where a client authorizes a third party to generate a proof under strict constraints.</p>
            <p>Techniques such as secure enclaves, multi-party computation, and encrypted inputs allow servers to assist with proving while reducing trust requirements. These approaches aim to combine the performance of server-side proving with the privacy guarantees of client-side execution.</p>

            <h2>Use Cases and When to Choose Each Model</h2>
            <p>Different applications naturally align with different proving architectures.</p>
            <p>High-throughput systems such as rollups, DeFi protocols, and bridges typically rely on server-side proving. The performance requirements are too demanding for widespread client-side execution.</p>
            <p>Privacy-sensitive applications, including identity, credentials, and selective disclosure compliance systems, benefit from client-side proving. Here, minimizing data exposure outweighs raw speed.</p>
            <p>Mobile and wallet-based applications often require careful trade-offs. Lightweight client-side proving may work for simple checks, while heavier proofs are delegated.</p>
            <p>Enterprise and regulated environments frequently prefer controlled server-side proving combined with strong auditability and compliance guarantees.</p>
            <p>For architects and protocol designers, the key decision criteria include performance needs, privacy requirements, trust assumptions, regulatory constraints, and expected user hardware.</p>

            <h2>Conclusion</h2>
            <p>At Bonsol, we focus on building infrastructure that makes verifiable computation usable in real systems. That means confronting trade-offs directly rather than pretending they disappear with the right abstraction. Privacy, trust, and scalability are shaped less by ideology and more by where and how proofs are generated.</p>
            <p>Client-side and server-side proving are not opposing philosophies. They are tools. Each performs well under different constraints, and strong systems are explicit about why they choose one, the other, or a combination of both. Where proofs are generated determines who must be trusted, how data is exposed, and how far a system can scale.</p>
            <p>Today, Bonsol’s prover network provides a production-grade foundation for server-side proving, with safeguards such as vetted prover operators, careful operational oversight, and proof segmentation to limit data exposure. In parallel, QCash represents our exploration of client-side proving, pushing toward maximum privacy by keeping sensitive inputs on the user’s device.</p>
            <p>Together, these efforts reflect where we are building toward: a hybrid model that supports both server-side and client-side proving, allowing the Bonsol platform to offer a spectrum of privacy and trust guarantees based on application needs.</p>
            <p>The key takeaway is simple. Proving location is not an implementation detail. It is a core system design choice, and Bonsol is being built to give teams the flexibility to make that choice deliberately, without sacrificing practicality or scale.</p>

            <br>
            <h3>Start building on Bonsol today:</h3>
            <p><a href="https://bonsol.org/">Website</a> | <a href="https://bonsol.gitbook.io/docs">Docs</a> | <a href="https://github.com/bonsol-collective/bonsol">GitHub</a> | <a href="https://x.com/bonsol_labs">X</a> | <a href="https://t.me/bonsolsh">Telegram</a> | <a href="https://discord.gg/Met32WpN">Discord</a></p>
        </div>
    </div>
</body>
</html>

